/*
this is code mostly generated by Microsoft Copilot, using GPT4 on Dec. 29th-30th 2023,
  when asking to port pasted C# code to Rust

i fixed and replaced a few things to make it compile, and it's initially finding
  fewer than expected polycubes for each rotational symmetry, and it's panic'ing
  in count_extensions_subset_inner() on an "attempt to add with overflow"

for initial testing, i found that the C# code produces the expected final count
  for N = 6, FILTER_DEPTH = 5, THREADS = 2, so i am initially using that to
  compare both programs' output

*/

//use std::cell::Ref;
use std::time::Duration;
use std::time::Instant;
use std::thread;
//use std::sync::{Arc, Mutex};
//use std::sync::mpsc;
use std::collections::HashSet;
//use std::mem;

const N: usize = 6; // number of polycube cells. Need n >= 4 if single threading, or n >= filterDepth >= 5 if multithreading (I think)
const FILTER_DEPTH: usize = 5;
const THREADS: i32 = 2;	

const X: i32 = (N as i32 + 5) / 4 * ((N as i32 + 5) / 4 * 3 - 2); // set X<Y<Z such that aX+bY+cZ = 0 implies a = b = c = 0 or |a|+|b|+|c| > n
const Y: i32 = X + 1; // trivial choice is X = 1, Y = n, Z = n * n. A simple reduction is X = 1, Y = n, Z = n * (n / 2) + (n + 1) / 2
const Z: i32 = X + (N as i32 + 5) / 4 * 3; // minimising Z is memory efficient. Unclear if this noticably affects performance. Z ~ 3/16 n^2 is the best I can find for arbitrary n

const X2: usize = (X + X) as usize;
const Y2: usize = (Y + Y) as usize;
const Z2: usize = (Z + Z) as usize;
const SYX: usize = (Y + X) as usize;
const SZX: usize = (Z + X) as usize;
const SZY: usize = (Z + Y) as usize;
const DYX: usize = (Y - X) as usize;
const DZX: usize = (Z - X) as usize;
const DZY: usize = (Z - Y) as usize;

pub fn seconds_to_dur(s: f64) -> String {
	let days = (s / 86400.0).floor();
	let hours = ((s - (days * 86400.0)) / 3600.0).floor();
	let minutes = ((s - (days * 86400.0) - (hours * 3600.0)) / 60.0).floor();
	let seconds = s - (days * 86400.0) - (hours * 3600.0) - (minutes * 60.0);
	let fsec = format!("{}{:.3}", if seconds < 10.0 { "0" } else { "" }, seconds);
	if days > 0.0 {
		return format!("{} days {:0>2}h:{:0>2}m:{}s", days, hours, minutes, fsec);
	}
	return format!("{:0>2}h:{:0>2}m:{}s", hours, minutes, fsec);
}

fn main() {
	let mut count: usize = 0; // enumerate the sum over the order 24 group of the size of the fix of each group element, and divide by 24 (Burnside's lemma)
	{
		let sw = Instant::now();
		let descriptions = [
			"orthogonal order 2 rotation",
			"orthogonal order 4 rotation",
			"short diagonal order 2 rotation",
			"long diagonal order 3 rotation"
		];
		let aut_class_sizes: [usize; 4] = [3, 6, 6, 8];
		let matrix_reps = [
			[-1, 0, 0, 0, -1, 0, 0, 0, 1],
			[0, -1, 0, 1, 0, 0, 0, 0, 1],
			[0, 1, 0, 1, 0, 0, 0, 0, -1],
			[0, 0, 1, 1, 0, 0, 0, 1, 0]
		];
		let affine1 = [
			[1, 0, 0],
			[1, 0, 0],
			[1, -1, 0],
			[1, 0, -1]
		];
		let affine2 = [
			[0, 1, 0],
			[0, 1, 0],
			[0, 0, 1],
			[0, 1, -1]
		];
		let biases = [
			[(2 * N) as i32, (2 * N) as i32, 0],
			[(2 * N) as i32, 0, 0],
			[0, 0, 2],
			[(N - 1) as i32, 0, 1 - (N as i32)]
		];
		for sym in 0..4 {
			let mut subcount = 0;
			for i in (1 - (N as i32))..(N as i32) {
				for j in (1 - (N as i32) + i.abs())..=((N as i32) - 1 - i.abs()) {
					subcount += count_symmetric_polycubes(
						&matrix_reps[sym],
						[
							i * affine1[sym][0] + j * affine2[sym][0] + biases[sym][0],
							i * affine1[sym][1] + j * affine2[sym][1] + biases[sym][1],
							i * affine1[sym][2] + j * affine2[sym][2] + biases[sym][2]
						]);
				}
			}
			println!("{} polycubes fixed under each {}", subcount, descriptions[sym]);
			println!("{} in total (symmetry occurs {} times)", aut_class_sizes[sym] * subcount, aut_class_sizes[sym]);
			count += aut_class_sizes[sym] * subcount;
		}
		println!("total count for nontrivial symmetries is {} for polycubes with {} cells\nTook {}", count, N, seconds_to_dur(sw.elapsed().as_secs_f64()));
	}
/*
	println!();
	{
		let sw = Instant::now();
		let mut subcount = 0;
		let (tx, rx) = mpsc::channel(); // create a channel for communication between threads
		let mut i = 4 * (N - FILTER_DEPTH) - 2; // this is the maximum left stack length, which is the value being filtered to separate work
		for _ in 0..THREADS {
			let filter = i; // copy of i, since closure captures the variable
			let tx = tx.clone(); // clone the sender for each thread
			thread::spawn(move || {
				tx.send(count_extensions_subset(filter)).unwrap(); // send the result to the channel
			});
			i -= 1;
		}
		while i >= 0 {
			subcount += rx.recv().unwrap(); // receive the result from the channel
			let filter = i; // copy of i, since closure captures the variable
			let tx = tx.clone(); // clone the sender for each thread
			thread::spawn(move || {
				tx.send(count_extensions_subset(filter)).unwrap(); // send the result to the channel
			});
			i -= 1;
		}
		drop(tx); // drop the sender to close the channel
		for _ in 0..THREADS {
			subcount += rx.recv().unwrap(); // receive the remaining results from the channel
		}
		count += subcount;
		println!("{} polycubes with {} cells (number of polycubes fixed by trivial symmetry)", subcount, N);
		println!("total count for all symmetries is {} for polycubes with {} cells\nTook {} h:m:s", count, N, sw.elapsed());
	}
*/
	{
		let sw = Instant::now();
		let mut subcount: usize = 0;
		let mut tasks = Vec::new(); // please don't judge my multithreading - this was basically just my first attempt, to see if it helped
		let mut jobs_remaining: isize = (4 * (N as i32 - FILTER_DEPTH as i32) - 2).try_into().unwrap(); // this is the maximum left stack length, which is the value being filtered to separate work
		for _ in 0..THREADS {
			let filter = jobs_remaining; // copy of i, since lambda expression captures the variable
			jobs_remaining -= 1;
			let handle = thread::spawn(move || count_extensions_subset(filter as usize));
			tasks.push(handle);
		}
		let mut handle_index_to_replace: Option<usize> = None;
		// why should this continue once more when jobs_remaining == 0?
		while jobs_remaining >= 0 {
			let mut j = 0;
			while j < tasks.len() {
				if tasks[j].is_finished() {
					handle_index_to_replace = Some(j);
					break;
				}
				thread::sleep(Duration::from_millis(50));
				j += 1;
			}
			if handle_index_to_replace.is_none() {
				continue;
			}
			subcount += tasks.remove(handle_index_to_replace.unwrap()).join().unwrap();
			let filter = jobs_remaining; // copy of i, since lambda expression captures the variable
			jobs_remaining -= 1;
			let handle = thread::spawn(move || count_extensions_subset(filter as usize));
			tasks.push(handle);

			//let j = tasks.iter().position(|t| t.join().is_ok()).unwrap(); // find the first completed task
			//subcount += tasks[j].join().unwrap();
			//let filter = i; // copy of i, since lambda expression captures the variable
			//i -= 1;
			//let handle = thread::spawn(move || count_extensions_subset(filter));
			//tasks[j] = handle; // replace the completed task with a new one
		}
		subcount += tasks.into_iter().map(|t| t.join().unwrap()).sum::<usize>(); // collect the results from all tasks
		count += subcount;
		println!("{:} polycubes with {} cells (number of polycubes fixed by trivial symmetry)\nTook {}", subcount, N, seconds_to_dur(sw.elapsed().as_secs_f64()));
	}
	println!();
	count /= 24;
	println!("{:} free polycubes with {} cells", count, N);
}


fn count_symmetric_polycubes(linear_map: &[i32; 9], affine_shift: [i32; 3]) -> usize {
	let mut adj_counts = vec![vec![vec![0u8; (N + 2) as usize]; (2 * N + 1) as usize]; (2 * N + 1) as usize];
	for z in 0..2 {
		for y in 0..(2 * N + 1) {
			for x in 0..(2 * N + 1) {
				adj_counts[x as usize][y as usize][z as usize] = 1;
				if z == 1 && y == N && x == N {
					break;
				}
			}
		}
	}
	let mut required_cells = HashSet::new();
	let mut ext_stack: Vec<(i32, i32, i32)> = Vec::new();
	ext_stack.push((N as i32, N as i32, 1));
	let mut recovery_stack: Vec<(i32, i32, i32)> = Vec::new();
	return count_extensions(N as i32, &mut adj_counts, &mut required_cells, &mut ext_stack, &mut recovery_stack, linear_map, affine_shift);
}

fn count_extensions(
		mut cells_to_add: i32,
		adj_counts: &mut Vec<Vec<Vec<u8>>>,
		required_cells: &mut HashSet<(i32, i32, i32)>,
		ext_stack: &mut Vec<(i32, i32, i32)>,
		recovery_stack: &mut Vec<(i32, i32, i32)>,
		linear_map: &[i32; 9],
		affine_shift: [i32; 3]) -> usize {
	cells_to_add -= 1;
	let mut count = 0;
	let original_length = ext_stack.len();
	while let Some((x, y, z)) = ext_stack.pop() {
		recovery_stack.push((x, y, z));

		let existing_requirement = required_cells.remove(&(x, y, z));
		if !existing_requirement {
			if cells_to_add < required_cells.len() as i32 {
				continue; // number of req cells will only grow...
			}
			let mut temp_x = x;
			let mut temp_y = y;
			let mut temp_z = z;
			loop // works for general transformations of finite order
			{
				let (tx, ty, tz) = (
					linear_map[0] * temp_x + linear_map[1] * temp_y + linear_map[2] * temp_z + affine_shift[0],
					linear_map[3] * temp_x + linear_map[4] * temp_y + linear_map[5] * temp_z + affine_shift[1],
					linear_map[6] * temp_x + linear_map[7] * temp_y + linear_map[8] * temp_z + affine_shift[2],
				);
				temp_x = tx;
				temp_y = ty;
				temp_z = tz;
				if x == temp_x && y == temp_y && z == temp_z {
					break;
				}
				required_cells.insert((temp_x, temp_y, temp_z));
			}
		}

		if cells_to_add >= required_cells.len() as i32 {
			// if there are too many req cells...
			if cells_to_add == 0 {
				count += 1;
			} else {
				let inner_original_length = ext_stack.len();
				/*
				if (adjacencyCounts[x - 1, y, z]++ == 0) extensionStack.Push((x - 1, y, z));
				if (adjacencyCounts[x, y - 1, z]++ == 0) extensionStack.Push((x, y - 1, z));
				if (adjacencyCounts[x, y, z - 1]++ == 0) extensionStack.Push((x, y, z - 1));
				if (adjacencyCounts[x + 1, y, z]++ == 0) extensionStack.Push((x + 1, y, z));
				if (adjacencyCounts[x, y + 1, z]++ == 0) extensionStack.Push((x, y + 1, z));
				if (adjacencyCounts[x, y, z + 1]++ == 0) extensionStack.Push((x, y, z + 1));
				 */
				// MS Copilot generated the following two lines:
				//if mem::replace(&mut adj_counts[(x - 1) as usize][y as usize][z as usize], 0) == 0 { ext_stack.push_back((x - 1, y, z)); }
				//if mem::replace(&mut adj_counts[x as usize][(y - 1) as usize][z as usize], 0) == 0 { ext_stack.push_back((x, y - 1, z)); }
				//if adj_counts[(x - 1) as usize][y as usize][z as usize] == 0 { ext_stack.push_back((x - 1, y, z)); } adj_counts[(x - 1) as usize][y as usize][z as usize] += 1;
				let adj_count: &mut u8 = &mut adj_counts[(x - 1) as usize][y as usize][z as usize];
				if *adj_count == 0 { ext_stack.push((x - 1, y, z)); } *adj_count += 1;
				let adj_count: &mut u8 = &mut adj_counts[x as usize][(y - 1) as usize][z as usize];
				if *adj_count == 0 { ext_stack.push((x, y - 1, z)); } *adj_count += 1;
				let adj_count: &mut u8 = &mut adj_counts[x as usize][y as usize][(z - 1) as usize];
				if *adj_count == 0 { ext_stack.push((x, y, z - 1)); } *adj_count += 1;
				let adj_count: &mut u8 = &mut adj_counts[(x + 1) as usize][y as usize][z as usize];
				if *adj_count == 0 { ext_stack.push((x + 1, y, z)); } *adj_count += 1;
				let adj_count: &mut u8 = &mut adj_counts[x as usize][(y + 1) as usize][z as usize];
				if *adj_count == 0 { ext_stack.push((x, y + 1, z)); } *adj_count += 1;
				let adj_count: &mut u8 = &mut adj_counts[x as usize][y as usize][(z + 1) as usize];
				if *adj_count == 0 { ext_stack.push((x, y, z + 1)); } *adj_count += 1;

				count += count_extensions(
					cells_to_add,
					adj_counts,
					required_cells,
					ext_stack,
					recovery_stack,
					linear_map,
					affine_shift,
				);
				adj_counts[(x - 1) as usize][y as usize][z as usize] -= 1;
				adj_counts[x as usize][(y - 1) as usize][z as usize] -= 1;
				adj_counts[x as usize][y as usize][(z - 1) as usize] -= 1;
				adj_counts[(x + 1) as usize][y as usize][z as usize] -= 1;
				adj_counts[x as usize][(y + 1) as usize][z as usize] -= 1;
				adj_counts[x as usize][y as usize][(z + 1) as usize] -= 1;
				while ext_stack.len() != inner_original_length {
					ext_stack.pop(); //should replace this with custom stack to avoid this unnecessary loop
				}
			}
		}

		if existing_requirement {
			required_cells.insert((x, y, z));
			break; //this required cell will no longer be available in the extension stack, so no more valid polycubes are possible in this branch
		} else {
			let mut temp_x = x;
			let mut temp_y = y;
			let mut temp_z = z;
			loop {
				let (tx, ty, tz) = (
					linear_map[0] * temp_x + linear_map[1] * temp_y + linear_map[2] * temp_z + affine_shift[0],
					linear_map[3] * temp_x + linear_map[4] * temp_y + linear_map[5] * temp_z + affine_shift[1],
					linear_map[6] * temp_x + linear_map[7] * temp_y + linear_map[8] * temp_z + affine_shift[2],
				);
				temp_x = tx;
				temp_y = ty;
				temp_z = tz;
				if x == temp_x && y == temp_y && z == temp_z {
					break;
				}
				required_cells.remove(&(temp_x, temp_y, temp_z));
			}
		}
	}
	while ext_stack.len() != original_length {
		ext_stack.push(recovery_stack.pop().unwrap());
	}
	return count;
}

fn count_extensions_subset(filter: usize) -> usize {

	unsafe {
		// moved these to the top of the file
		//const X: i32 = (N as i32 + 5) / 4 * ((N as i32 + 5) / 4 * 3 - 2); // set X<Y<Z such that aX+bY+cZ = 0 implies a = b = c = 0 or |a|+|b|+|c| > n
		//const Y: i32 = X + 1; // trivial choice is X = 1, Y = n, Z = n * n. A simple reduction is X = 1, Y = n, Z = n * (n / 2) + (n + 1) / 2
		//const Z: i32 = X + (N as i32 + 5) / 4 * 3; // minimising Z is memory efficient. Unclear if this noticably affects performance. Z ~ 3/16 n^2 is the best I can find for arbitrary n
		// don't know what copilot was doing here
		//let byte_board = std::alloc::alloc_zeroed(std::alloc::Layout::array::<u8>((N + 2) * Z as usize).unwrap()) as *mut u8; // could use ints or shorts as offsets to save memory, but it's faster to directly store the pointers to avoid adding pointer offsets at every lookup
		//let ref_stack = std::alloc::alloc_zeroed(std::alloc::Layout::array::<*mut u8>((N - 2) * 4 as usize).unwrap()) as *mut *mut u8; // total length of the two stacks is at most 4n-9. One stack grows from the left, the other stack grows from the right
		let mut byte_board_arr: [u8; (N as usize+ 2) * Z as usize] = [0; (N as usize + 2) * Z as usize];
		let mut byte_board = byte_board_arr.as_mut_ptr();
		let mut ref_stack_arr: [*mut u8; (N - 2) * 4] = [std::ptr::null_mut(); (N - 2) * 4];
		let ref_stack = ref_stack_arr.as_mut_ptr();
		byte_board = byte_board.offset(Z as isize); // seeded with first index of the byte board as the only allowed extension
		//*ref_stack = byte_board.add(Z as usize);
		//for i in (byte_board as usize..byte_board.add((N + 1) * Z as usize) as usize).rev() {
		//	*i as *mut u8 = 255; // the first Z + 1 bytes are disallowed extensions; first Z are less than the minimum, last 1 due to edge case of initial polycube having no neighbours
		//}
		*ref_stack = byte_board;
		let mut i = byte_board.offset((N as isize + 1) * Z as isize);
		while i != byte_board {
			i = i.sub(1);
			*i = 255;
		}

		println!("started task {}", filter);
		let count: usize = count_extensions_subset_inner(N as usize, ref_stack.add(1), ref_stack.add((N - 2) * 4 as usize), ref_stack, filter);
		println!("finished task {} with subcount {}", filter, count);
		return count;

		/*
		fn count_extensions_subset_inner(depth: i32, stack_top_1: *mut *mut u8, stack_top_2: *mut *mut u8) -> i64 {
			let mut count = 0;
			let stack_top_original = stack_top_1;
			while stack_top_1 != ref_stack {
				let index = *stack_top_1.sub(1);
				let mut stack_top_inner = stack_top_1;
				if (*index.sub(X as usize) += 1) == 0 {
					*stack_top_inner = index.sub(X as usize);
					stack_top_inner = stack_top_inner.add(1);
				}
				if (*index.sub(Y as usize) += 1) == 0 {
					*stack_top_inner = index.sub(Y as usize);
					stack_top_inner = stack_top_inner.add(1);
				}
				if (*index.sub(Z as usize) += 1) == 0 {
					*stack_top_inner = index.sub(Z as usize);
					stack_top_inner = stack_top_inner.add(1);
				}
				if (*index.add(X as usize) += 1) == 0 {
					*stack_top_inner = index.add(X as usize);
					stack_top_inner = stack_top_inner.add(1);
				}
				if (*index.add(Y as usize) += 1) == 0 {
					*stack_top_inner = index.add(Y as usize);
					stack_top_inner = stack_top_inner.add(1);
				}
				if (*index.add(Z as usize) += 1) == 0 {
					*stack_top_inner = index.add(Z as usize);
					stack_top_inner = stack_top_inner.add(1);
				}
				if depth == 4 {
					count += count_extensions_subset_final(stack_top_inner);
				} else if depth != filter_depth || stack_top_1.sub(ref_stack as usize) == filter {
					count += count_extensions_subset_inner(depth - 1, stack_top_inner, stack_top_2); // if multithreading is not wanted, remove "if (condition)" from this else statement
				}
				*index.sub(X as usize) -= 1;
				*index.sub(Y as usize) -= 1;
				*index.sub(Z as usize) -= 1;
				*index.add(X as usize) -= 1;
				*index.add(Y as usize) -= 1;
				*index.add(Z as usize) -= 1;
				*stack_top_2.sub(1) = index; // doing this push before the recursion would add one extra unnecessary element to the stack at each level of recursion
			}
			while stack_top_1 != stack_top_original {
				*stack_top_1 = *stack_top_2;
				stack_top_1 = stack_top_1.add(1);
				stack_top_2 = stack_top_2.add(1);
			}
			return count;
		}
		*/
	}
}

fn count_extensions_subset_inner(depth: usize, mut stack_top_1: *mut *mut u8, mut stack_top_2: *mut *mut u8, ref_stack: *mut *mut u8, filter: usize) -> usize {
	unsafe {
		let mut count: usize = 0;
		let stack_top_original = stack_top_1;
		let filter_stop = ref_stack.add(filter);
		while stack_top_1 != ref_stack {
			stack_top_1 = stack_top_1.sub(1);
			let index = *stack_top_1;
			let mut stack_top_inner = stack_top_1;
			/*
			if (++*(index - X) == 0) *stackTopInner++ = index - X;
			if (++*(index - Y) == 0) *stackTopInner++ = index - Y;
			if (++*(index - Z) == 0) *stackTopInner++ = index - Z;
			if (++*(index + X) == 0) *stackTopInner++ = index + X;
			if (++*(index + Y) == 0) *stackTopInner++ = index + Y;
			if (++*(index + Z) == 0) *stackTopInner++ = index + Z;
			*/
			let incr = index.sub(X as usize); *incr += 1; if *incr == 0 { *stack_top_inner = index.sub(X as usize); stack_top_inner = stack_top_inner.add(1); }
			let incr = index.sub(Y as usize); *incr += 1; if *incr == 0 { *stack_top_inner = index.sub(Y as usize); stack_top_inner = stack_top_inner.add(1); }
			let incr = index.sub(Z as usize); *incr += 1; if *incr == 0 { *stack_top_inner = index.sub(Z as usize); stack_top_inner = stack_top_inner.add(1); }
			let incr = index.add(X as usize); *incr += 1; if *incr == 0 { *stack_top_inner = index.add(X as usize); stack_top_inner = stack_top_inner.add(1); }
			let incr = index.add(Y as usize); *incr += 1; if *incr == 0 { *stack_top_inner = index.add(Y as usize); stack_top_inner = stack_top_inner.add(1); }
			let incr = index.add(Z as usize); *incr += 1; if *incr == 0 { *stack_top_inner = index.add(Z as usize); stack_top_inner = stack_top_inner.add(1); }
			// this is what MS Copilot generated:
			//if (*index.sub(X as usize) += 1) == 0 {
			//	*stack_top_inner = index.sub(X as usize);
			//	stack_top_inner = stack_top_inner.add(1);
			//}
			//if (*index.sub(Y as usize) += 1) == 0 {
			//	*stack_top_inner = index.sub(Y as usize);
			//	stack_top_inner = stack_top_inner.add(1);
			//}
			//if (*index.sub(Z as usize) += 1) == 0 {
			//	*stack_top_inner = index.sub(Z as usize);
			//	stack_top_inner = stack_top_inner.add(1);
			//}
			//if (*index.add(X as usize) += 1) == 0 {
			//	*stack_top_inner = index.add(X as usize);
			//	stack_top_inner = stack_top_inner.add(1);
			//}
			//if (*index.add(Y as usize) += 1) == 0 {
			//	*stack_top_inner = index.add(Y as usize);
			//	stack_top_inner = stack_top_inner.add(1);
			//}
			//if (*index.add(Z as usize) += 1) == 0 {
			//	*stack_top_inner = index.add(Z as usize);
			//	stack_top_inner = stack_top_inner.add(1);
			//}
			if depth == 4 {
				count += count_extensions_subset_final(stack_top_inner, ref_stack);
			} else if depth != FILTER_DEPTH || stack_top_1.sub(ref_stack as usize) == filter_stop {
				count += count_extensions_subset_inner(depth - 1, stack_top_inner, stack_top_2, ref_stack, filter); // if multithreading is not wanted, remove "if (condition)" from this else statement
			}
			*index.sub(X as usize) -= 1;
			*index.sub(Y as usize) -= 1;
			*index.sub(Z as usize) -= 1;
			*index.add(X as usize) -= 1;
			*index.add(Y as usize) -= 1;
			*index.add(Z as usize) -= 1;
			*stack_top_2.sub(1) = index; // doing this push before the recursion would add one extra unnecessary element to the stack at each level of recursion
		}
		while stack_top_1 != stack_top_original {
			*stack_top_1 = *stack_top_2;
			stack_top_1 = stack_top_1.add(1);
			stack_top_2 = stack_top_2.add(1);
		}
		return count;
	}
}

fn count_extensions_subset_final(mut stack_top: *mut *mut u8, ref_stack: *mut *mut u8) -> usize {
	/*
	const int X2 = X + X, Y2 = Y + Y, Z2 = Z + Z, sYX = Y + X, sZX = Z + X, sZY = Z + Y, dYX = Y - X, dZX = Z - X, dZY = Z - Y;
	int length = (int)(stackTop - refStack);
	int count = length * (length - 1) * (length - 2) / 6;
	byte** stackTopTemp = stackTop;
	while (stackTopTemp != refStack)
	{
		byte* i = *--stackTopTemp;
		int neighbours = 0;
		int subcount = 128;
		if (*(i - X) > 127) { neighbours++; subcount += *(i - X2) + *(i - sYX) + *(i - sZX) + *(i + dYX) + *(i + dZX); count += --*(i - X); }
		if (*(i - Y) > 127) { neighbours++; subcount += *(i - Y2) + *(i - sYX) + *(i - sZY) + *(i - dYX) + *(i + dZY); count += --*(i - Y); }
		if (*(i - Z) > 127) { neighbours++; subcount += *(i - Z2) + *(i - sZX) + *(i - sZY) + *(i - dZX) + *(i - dZY); count += --*(i - Z); }
		if (*(i + X) > 127) { neighbours++; subcount += *(i + X2) + *(i + sYX) + *(i + sZX) + *(i - dYX) + *(i - dZX); count += --*(i + X); }
		if (*(i + Y) > 127) { neighbours++; subcount += *(i + Y2) + *(i + sYX) + *(i + sZY) + *(i + dYX) + *(i - dZY); count += --*(i + Y); }
		if (*(i + Z) > 127) { neighbours++; subcount += *(i + Z2) + *(i + sZX) + *(i + sZY) + *(i + dZX) + *(i + dZY); count += --*(i + Z); }
		count += (subcount >> 8) + (neighbours * (neighbours + ((length << 1) - 511)) >> 1);
	}
	while (stackTop != refStack)
	{
		byte* i = *--stackTop;
		*(i - X) |= (byte)(*(i - X) >> 4);
		*(i - Y) |= (byte)(*(i - Y) >> 4);
		*(i - Z) |= (byte)(*(i - Z) >> 4);
		*(i + X) |= (byte)(*(i + X) >> 4);
		*(i + Y) |= (byte)(*(i + Y) >> 4);
		*(i + Z) |= (byte)(*(i + Z) >> 4);
	}
	return count;
	*/
	unsafe {
		let length = stack_top.offset_from(ref_stack);
		let mut count: usize = (length * (length - 1) * (length - 2) / 6).try_into().unwrap();
		let mut stack_top_temp = stack_top;
		while stack_top_temp != ref_stack {
			stack_top_temp = stack_top_temp.sub(1);
			let i = *stack_top_temp;
			let mut neighbours = 0;
			let mut subcount: usize = 128;
			let incr = i.sub(X as usize); if *incr > 127 { neighbours += 1; subcount += *incr.sub(X2) as usize + *incr.sub(SZX) as usize + *incr.add(DYX) as usize + *incr.add(DZX) as usize; *incr.sub(X as usize) -= 1; count += *incr as usize; }
			let incr = i.sub(Y as usize); if *incr > 127 { neighbours += 1; subcount += *incr.sub(Y2) as usize + *incr.sub(SZY) as usize + *incr.sub(DYX) as usize + *incr.add(DZY) as usize; *incr.sub(Y as usize) -= 1; count += *incr as usize; }
			let incr = i.sub(Z as usize); if *incr > 127 { neighbours += 1; subcount += *incr.sub(Z2) as usize + *incr.sub(SZY) as usize + *incr.sub(DZX) as usize + *incr.sub(DZX) as usize; *incr.sub(Z as usize) -= 1; count += *incr as usize; }
			let incr = i.add(X as usize); if *incr > 127 { neighbours += 1; subcount += *incr.add(X2) as usize + *incr.add(SZX) as usize + *incr.sub(DYX) as usize + *incr.sub(DYX) as usize; *incr.add(X as usize) -= 1; count += *incr as usize; }
			let incr = i.add(Y as usize); if *incr > 127 { neighbours += 1; subcount += *incr.add(Y2) as usize + *incr.add(SZY) as usize + *incr.add(DYX) as usize + *incr.sub(DYX) as usize; *incr.add(Y as usize) -= 1; count += *incr as usize; }
			let incr = i.add(Z as usize); if *incr > 127 { neighbours += 1; subcount += *incr.add(Z2) as usize + *incr.add(SZY) as usize + *incr.add(DZX) as usize + *incr.add(DZY) as usize; *incr.add(Z as usize) -= 1; count += *incr as usize; }
			count += (subcount >> 8) + ((neighbours * (neighbours + ((length << 1) - 511)) >> 1) as usize);
		}
		while stack_top != ref_stack {
			stack_top = stack_top.sub(1);
			let i = *stack_top;
			let incr = i.sub(X as usize); *incr |= *incr >> 4;
			let incr = i.sub(Y as usize); *incr |= *incr >> 4;
			let incr = i.sub(Z as usize); *incr |= *incr >> 4;
			let incr = i.add(X as usize); *incr |= *incr >> 4;
			let incr = i.add(Y as usize); *incr |= *incr >> 4;
			let incr = i.add(Z as usize); *incr |= *incr >> 4;
		}
		return count;
	}

}